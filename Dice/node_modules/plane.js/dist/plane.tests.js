'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var chai = require('chai');
var sinon = _interopDefault(require('sinon'));

var streamer = function (input) {
  let position = 0;
  let line = 1;
  let column = 0;

  const next = () => {
    const character = input.charAt(position);
    position += 1;
    if (character === '\n') {
      line += 1;
      column = 0;
    } else {
      column += 1;
    }
    return character;
  };

  const lookAhead = () => {
    const character = input.charAt(position + 1);
    return character;
  };

  const peek = () => input.charAt(position);

  const eof = () => (peek() === '');

  const fail = (msg) => {
    throw new Error(`${msg} (${line}:${column})`);
  };

  return {
    next,
    lookAhead,
    peek,
    eof,
    fail
  };
};

const KEYWORDS = ['if', 'else', 'fn', 'true', 'false'];
const OPERATORS = ['+', '-', '*', '/', '%', '=', '&', '|', '<', '>', '!'];
const PUNCTUATIONS = ['', ',', ';', '(', ')', '{', '}', '[', ']', '', '$'];
const WHITESPACE = [' ', '\t', '\n'];
const IDENTIFIERS = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'];
const NON_STARTING_IDENTIFIERS = ['?', '!', '-', '<', '>', '=', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];

function isKeyword(x) {
  const keywords = ` ${KEYWORDS.join(' ')} `;
  return keywords.indexOf(` ${x} `) >= 0;
}

function isDigit(character) {
  return /[0-9]/i.test(character);
}

function isIDStart(character) {
  return /[a-z]/i.test(character);
}

function isID(character) {
  return isIDStart(character) || NON_STARTING_IDENTIFIERS.join('').indexOf(character) >= 0;
}

function isOpChar(character) {
  return OPERATORS.join('').indexOf(character) >= 0;
}

function isPunc(character) {
  return PUNCTUATIONS.join('').indexOf(character) >= 0;
}

function isWhitespace(character) {
  return WHITESPACE.join('').indexOf(character) >= 0;
}

function readWhile(input, predicate, str = '') {
  if (!input.eof() && predicate(input.peek())) {
    const concatenated = str + input.next();

    return readWhile(input, predicate, concatenated);
  }
  return str;
}

function readNumber(input) {
  let hasDot = false;
  const number = readWhile(input, (character) => {
    if (character === '.') {
      if (hasDot) {
        return false;
      }
      hasDot = true;
      return true;
    }
    return isDigit(character);
  });

  return {
    type: 'num',
    value: parseFloat(number)
  };
}

function readIdent(input) {
  const id = readWhile(input, isID);
  const type = isKeyword(id) ? 'keyword' : 'const';

  return {
    type,
    value: id
  };
}

const isTemplateExpression = input => (input.peek() === '$' && input.lookAhead() === '{');

function readEscaped(input, end, string = '', expressions = [], quasis = []) {
  let escaped = false;
  input.next();

  while (!input.eof()) {
    const character = input.next();
    if (isTemplateExpression(input)) {
      quasis.push({ type: 'str', value: string + character });
      input.next();
      input.next();
      const id = readIdent(input);
      expressions.push(id);

      return readEscaped(input, '"', '', expressions, quasis);
    }
    if (escaped) {
      // eslint-disable-next-line no-param-reassign
      string += character;
      escaped = false;
    } else if (character === '\\') {
      escaped = true;
    } else if (character === end) {
      break;
    } else {
      // eslint-disable-next-line no-param-reassign
      string += character;
    }
  }
  if (expressions.length > 0 || quasis.length > 0) {
    quasis.push({ type: 'str', value: string });
    return {
      expressions,
      quasis
    };
  }
  return string;
}

function readString(input) {
  const value = readEscaped(input, '"');
  const type = (typeof value === 'string') ? 'str' : 'template';

  return {
    type,
    value
  };
}

function skipComment(input) {
  readWhile(input, character => character !== '\n');
  input.next();
}

function readNext(input) {
  readWhile(input, isWhitespace);
  if (input.eof()) {
    return null;
  }
  const character = input.peek();

  if (character === '#') {
    skipComment(input);
    return readNext(input);
  }

  if (character === '"') {
    return readString(input);
  }

  if (isDigit(character)) {
    return readNumber(input);
  }

  if (isIDStart(character)) {
    return readIdent(input);
  }

  if (isPunc(character)) {
    return {
      type: 'punc',
      value: input.next()
    };
  }

  if (isOpChar(character)) {
    return {
      type: 'op',
      value: readWhile(input, isOpChar)
    };
  }

  return input.fail(`Unable to process character: ${character}`);
}

function lexer(input) {
  let current = null;

  function peek() {
    return current || (current = readNext(input));
  }

  function next() {
    const token = current;
    current = null;
    return token || readNext(input);
  }

  function eof() {
    return peek() === null;
  }

  return {
    next,
    peek,
    eof,
    fail: input.fail
  };
}

function isPunc$1(input, character) {
  const token = input.peek();
  if (token && token.type === 'punc' && (!character || token.value === character)) {
    return token;
  }
  return false;
}

function isKeyword$1(input, keyword) {
  const token = input.peek();
  if (token && token.type === 'keyword' && (!keyword || token.value === keyword)) {
    return token;
  }
  return false;
}

function isOperator(input, operator) {
  const token = input.peek();
  if (token && token.type === 'op' && (!operator || token.value === operator)) {
    return token;
  }
  return false;
}

function skipPunc(input, character) {
  if (isPunc$1(input, character)) {
    input.next();
  } else {
    input.fail(`Expecting punctuation: ${character}`);
  }
}

function skipKeyword(input, keyword) {
  if (isKeyword$1(input, keyword)) {
    input.next();
  } else {
    input.fail(`Expecting keyword: "${keyword}"`);
  }
}



function unexpected(input) {
  input.fail(`Unexpected token: ${JSON.stringify(input.peek())}`);
}

/* eslint no-use-before-define: ["error", { "functions": false }] */

const PRECEDENCE = {
  '=': 1,
  '||': 2,
  '&&': 3,
  '<': 7,
  '>': 7,
  '<=': 7,
  '>=': 7,
  '==': 7,
  '!=': 7,
  '|>': 8,
  '+': 10,
  '-': 10,
  '*': 20,
  '/': 20,
  '%': 20,
  '**': 30
};

const FALSE = {
  type: 'bool',
  value: false
};

function delimited(input, start, stop, separator, parser) {
  const a = [];
  let first = true;
  skipPunc(input, start);
  while (!input.eof()) {
    if (isPunc$1(input, stop)) {
      break;
    }
    if (first) {
      first = false;
    } else {
      skipPunc(input, separator);
    }
    if (isPunc$1(input, stop)) {
      break;
    }
    a.push(parser(input));
  }
  skipPunc(input, stop);
  return a;
}

function parseConstName(input) {
  const name = input.next();
  if (name.type !== 'const') {
    input.fail('Expecting constant name');
  }
  return name.value;
}

function parseCall(input, func) {
  const args = delimited(input, '(', ')', ',', parseExpression);
  return {
    type: 'call',
    func,
    args
  };
}

function parseBool(input) {
  const value = (input.next().value === 'true');
  return {
    type: 'bool',
    value
  };
}

function maybeCall(input, expression) {
  const exp = expression();
  return isPunc$1(input, '(') ? parseCall(input, exp) : exp;
}

function parseLambda(input) {
  const constants = delimited(input, '(', ')', ',', parseConstName);
  const body = parseExpression(input);
  return {
    type: 'fn',
    constants,
    body
  };
}

function parseIf(input) {
  skipKeyword(input, 'if');
  const condition = parseExpression(input);
  const then = parseExpression(input);
  const conditional = {
    type: 'if',
    condition,
    then
  };
  if (isKeyword$1(input, 'else')) {
    input.next();
    return Object.assign({}, conditional, {
      else: parseExpression(input)
    });
  }
  return conditional;
}

function parseProg(input) {
  const prog = delimited(input, '{', '}', ';', parseExpression);
  if (prog.length === 0) {
    return FALSE;
  }
  if (prog.length === 1) {
    return prog[0];
  }
  return {
    type: 'prog',
    prog
  };
}

function parseTemplate(input) {
  const { expressions, quasis } = input.value;

  return {
    type: 'string-template',
    expressions,
    quasis
  };
}

function parseAtom(input, fn) {
  return fn(input, () => {
    if (isPunc$1(input, '(')) {
      input.next();
      const expression = parseExpression(input);
      skipPunc(input, ')');
      return expression;
    }
    if (isPunc$1(input, '{')) {
      return parseProg(input);
    }
    if (isKeyword$1(input, 'if')) {
      return parseIf(input);
    }
    if (isKeyword$1(input, 'true') || isKeyword$1(input, 'false')) {
      return parseBool(input);
    }
    if (isKeyword$1(input, 'fn')) {
      input.next();
      return parseLambda(input);
    }
    const token = input.next();
    if (token.type === 'template') {
      return parseTemplate(token);
    }
    if (token.type === 'const' || token.type === 'num' || token.type === 'str') {
      return token;
    }
    return unexpected(input);
  });
}

function maybeBinary(input, left, precedence) {
  const token = isOperator(input);
  if (token) {
    const newPrecedence = PRECEDENCE[token.value];
    if (newPrecedence > precedence) {
      input.next();
      const type = token.value === '=' ? 'assign' : 'binary';
      const right = maybeBinary(input, parseAtom(input, maybeCall), newPrecedence);
      return maybeBinary(input, {
        type,
        left,
        operator: token.value,
        right
      }, precedence);
    }
  }
  return left;
}

function makeTopLevel(input, currentLines) {
  if (input.eof()) {
    return currentLines;
  }
  const newLines = currentLines.concat([parseExpression(input)]);
  skipPunc(input, ';');

  return makeTopLevel(input, newLines);
}

function parseExpression(input) {
  return maybeCall(input, () => maybeBinary(input, parseAtom(input, maybeCall), 0));
}

function parse(input, makeTopLevelFunc = makeTopLevel) {
  const prog = makeTopLevelFunc(input, []);

  return {
    type: 'prog',
    prog
  };
}

var standardLib = function (world) {
  // eslint-disable-next-line no-console
  world.set('log', val => console.log(val));
};

function checkScope(scope, name) {
  if (name in scope.constants) {
    return scope;
  }
  if (typeof scope.parent !== 'undefined') {
    return checkScope(scope.parent, name);
  }

  return false;
}

class World {
  constructor(parent) {
    this.constants = Object.create(null);
    this.parent = parent;
    standardLib(this);
  }

  extend() {
    const kepler = new World(this);
    return kepler;
  }

  lookup(name) {
    const scope = checkScope(this, name);
    return scope;
  }

  get(name) {
    const scope = this.lookup(name);
    if (scope !== false) {
      return scope.constants[name];
    }
    throw new Error(`Undefined constant: "${name}"`);
  }

  set(name, value) {
    if (this.constants[name]) {
      throw new Error(`Attempting to reassign constant: "${name}"`);
    }
    this.constants[name] = value;
    return this;
  }
}

function clearWorlds() {
  global.plane = {
    worlds: []
  };
}

class TestWorld extends World {
  constructor(parent, rootWorld) {
    super(parent);
    if (rootWorld === true) {
      clearWorlds();
    }
    global.plane.worlds.push(this);
  }
  extend() {
    return new TestWorld(this);
  }
}

const num = (x) => {
  if (typeof x !== 'number') {
    throw new Error(`Expected number but got: "${x}"`);
  }
  return x;
};

const div = (x) => {
  if (num(x) === 0) {
    throw new Error('Unable to divide number by zero');
  }
  return x;
};

function applyOperator(operator, left, right) {
  switch (operator) {
    case '+': {
      return num(left) + num(right);
    }
    case '-': {
      return num(left) - num(right);
    }
    case '*': {
      return num(left) * num(right);
    }
    case '/': {
      return num(left) / div(right);
    }
    case '%': {
      return num(left) % div(right);
    }
    case '**': {
      return num(left) ** num(right);
    }
    case '&&': {
      return left !== false && right;
    }
    case '||': {
      return left !== false ? left : right;
    }
    case '<': {
      return num(left) < num(right);
    }
    case '>': {
      return num(left) > num(right);
    }
    case '<=': {
      return num(left) <= num(right);
    }
    case '>=': {
      return num(left) >= num(right);
    }
    case '==': {
      return left === right;
    }
    case '!=': {
      return left !== right;
    }
    case '|>': {
      return right(left);
    }
    default: {
      throw new Error(`Unable to process operator ${operator}`);
    }
  }
}

function makeFunction(env, expression, evaluateFn) {
  const names = expression.constants;
  const kepler = env.extend();

  return function fn(...args) {
    let i = 0;

    names.forEach((name) => {
      kepler.set(name, (i < args.length) ? args[i] : false);
      i += 1;
    });

    return evaluateFn(expression.body, kepler);
  };
}

function makeTemplateString(world, expressions, quasis, evaluateFn) {
  return quasis.map((string, index) => {
    const evaluated = (typeof expressions[index] === 'undefined') ? '' : evaluateFn(expressions[index], world);
    return string.value + evaluated;
  }).join('');
}

function evaluate(expression, world) {
  switch (expression.type) {
    case 'num':
    case 'str':
    case 'bool': {
      return expression.value;
    }
    case 'const': {
      return world.get(expression.value);
    }
    case 'assign': {
      if (expression.left.type !== 'const') {
        throw new Error(`Cannot assign to ${JSON.stringify(expression.left)}`);
      }
      return world.set(expression.left.value, evaluate(expression.right, world));
    }
    case 'binary': {
      const left = evaluate(expression.left, world);
      const right = evaluate(expression.right, world);
      return applyOperator(expression.operator, left, right);
    }
    case 'string-template': {
      const { expressions, quasis } = expression;
      return makeTemplateString(world, expressions, quasis, evaluate);
    }
    case 'fn': {
      return makeFunction(world, expression, evaluate);
    }
    case 'if': {
      const condition = evaluate(expression.condition, world);
      if (condition !== false) {
        return evaluate(expression.then, world);
      }
      return expression.else ? evaluate(expression.else, world) : false;
    }
    case 'prog': {
      let val = false;
      expression.prog.forEach((exp) => {
        val = evaluate(exp, world);
      });
      return val;
    }
    case 'call': {
      const func = evaluate(expression.func, world);
      return func(...expression.args.map(arg => evaluate(arg, world)));
    }
    default: {
      throw new Error(`Unable to process expression: ${expression.type}`);
    }
  }
}

const run = (script) => {
  const stream = streamer(script);
  const tokenized = lexer(stream);
  const ast = parse(tokenized);
  const world = new TestWorld(undefined, true);

  evaluate(ast, world);

  return { stream, tokenized, ast };
};

describe('constant assignment', () => {
  it('assigns constants of strings, numbers and booleans', () => {
    const script = `
      stringConst = "stringConst";
      numberConst = 10;
      booleanConst = true;
    `;

    run(script);
    const [programWorld] = global.plane.worlds;

    chai.expect(programWorld.constants.stringConst).to.equal('stringConst');
    chai.expect(programWorld.constants.numberConst).to.equal(10);
    chai.expect(programWorld.constants.booleanConst).to.be.true;
  });

  it('assigns constants of type function', () => {
    const script = `
      func = fn(){};
    `;

    run(script);
    const [programWorld] = global.plane.worlds;

    chai.expect(typeof programWorld.constants.func).to.equal('function');
  });

  it('assigns constants to a scope', () => {
    const script = `
      globalConst = 10;
      func = fn() {
        globalConst = 20;
      };
      func();
    `;

    run(script);

    const [programWorld, funcWorld] = global.plane.worlds;

    chai.expect(programWorld.constants.globalConst).to.equal(10);
    chai.expect(funcWorld.constants.globalConst).to.equal(20);
  });
});

const run$1 = (script, world) => {
  const stream = streamer(script);
  const tokenized = lexer(stream);
  const ast = parse(tokenized);

  evaluate(ast, world);
};

describe('Pipe operator', () => {
  it('passes the output of the left expression to the right expression as a function call', () => {
    const script = `
      square = fn(x) {
        x * x;
      };
      cube = fn(x) {
        x * x * x;
      };
      squaredAndCubed = 2 |> square |> cube;
    `;
    const world = new World();

    run$1(script, world);

    chai.expect(world.constants.squaredAndCubed).to.equal(64);
  });
});

const run$2 = (script, world) => {
  const stream = streamer(script);
  const tokenized = lexer(stream);
  const ast = parse(tokenized);

  evaluate(ast, world);

  return { stream, tokenized, ast };
};

describe('String interpolation', () => {
  it('interpolates a single constant into the string', () => {
    // eslint-disable-next-line no-template-curly-in-string
    const script = 'name = "David";message = "Welcome ${name}!";log(message);';
    const world = new World();
    const application = run$2(script, world);

    const expectedAST = {
      type: 'string-template',
      expressions: [
        {
          type: 'const',
          value: 'name'
        }
      ],
      quasis: [
        {
          type: 'str',
          value: 'Welcome '
        },
        {
          type: 'str',
          value: '!'
        }
      ]
    };

    const templateAST = application.ast.prog[1].right;
    chai.expect(templateAST).to.deep.equal(expectedAST);
  });

  it('interpolates a multiple constants into the string', () => {
    // eslint-disable-next-line no-template-curly-in-string
    const script = 'name = "David";nickname = "Davey";message = "Welcome ${name}! How is ${nickname} today?";log(message);';
    const world = new World();
    const application = run$2(script, world);

    const expectedAST = {
      type: 'string-template',
      expressions: [
        {
          type: 'const',
          value: 'name'
        },
        {
          type: 'const',
          value: 'nickname'
        }
      ],
      quasis: [
        {
          type: 'str',
          value: 'Welcome '
        },
        {
          type: 'str',
          value: '! How is '
        },
        {
          type: 'str',
          value: ' today?'
        }
      ]
    };

    const templateAST = application.ast.prog[2].right;
    chai.expect(templateAST).to.deep.equal(expectedAST);
  });
  it('interpolates expressions into the string');
  it('interpolates calls into the string');
});

describe('Lexer', () => {
  describe('.peek()', () => {});
  describe('.next()', () => {});
  describe('.eof()', () => {});
  describe('.fail()', () => {});
});

const DIGITS = [1, 2, 3, 10, 11, 44.3];

describe('Lexer', () => {
  describe('-> matchers', () => {
    describe('.isKeyword()', () => {
      KEYWORDS.forEach((keyword) => {
        it(`returns true for the following keyword: "${keyword}"`, () => {
          chai.expect(isKeyword(keyword)).to.be.true;
        });
      });

      it('returns false for non keywords', () => {
        chai.expect(isKeyword('switch')).to.be.false;
      });
    });

    describe('.isDigit()', () => {
      DIGITS.forEach((digit) => {
        it(`returns true for digits: "${digit}"`, () => {
          chai.expect(isDigit(digit)).to.be.true;
        });
      });

      it('returns false for strings', () => {
        chai.expect(isDigit('switch')).to.be.false;
      });

      it('returns false for objects', () => {
        chai.expect(isDigit({})).to.be.false;
      });

      it('returns false for booleans', () => {
        chai.expect(isDigit(true)).to.be.false;
      });
    });

    describe('.isIDStart()', () => {
      IDENTIFIERS.forEach((identifier) => {
        it(`returns true for identifiers: "${identifier}"`, () => {
          chai.expect(isIDStart(identifier)).to.be.true;
        });
      });
      NON_STARTING_IDENTIFIERS.forEach((identifier) => {
        it(`returns false for the following non-starting identifiers: "${identifier}"`, () => {
          chai.expect(isIDStart(identifier)).to.be.false;
        });
      });
      OPERATORS.forEach((operator) => {
        it(`returns false for the following operators: "${operator}"`, () => {
          chai.expect(isIDStart(operator)).to.be.false;
        });
      });
    });
    describe('.isID()', () => {
      IDENTIFIERS.forEach((identifier) => {
        it(`returns true for identifiers: "${identifier}"`, () => {
          chai.expect(isID(identifier)).to.be.true;
        });
      });
      NON_STARTING_IDENTIFIERS.forEach((identifier) => {
        it(`returns true for the following non-starting identifiers: "${identifier}"`, () => {
          chai.expect(isID(identifier)).to.be.true;
        });
      });
    });
    describe('.isOpChar()', () => {
      OPERATORS.forEach((operator) => {
        it(`returns true for operators: "${operator}"`, () => {
          chai.expect(isOpChar(operator)).to.be.true;
        });
      });
    });

    describe('.isPunc()', () => {
      PUNCTUATIONS.forEach((punctuation) => {
        it(`returns true for punctuations: "${punctuation}"`, () => {
          chai.expect(isPunc(punctuation)).to.be.true;
        });
      });
    });
    describe('.isWhitespace()', () => {
      WHITESPACE.forEach((space) => {
        it(`returns true for punctuations: "${space}"`, () => {
          chai.expect(isWhitespace(space)).to.be.true;
        });
      });
    });
  });
});

describe('Lexer', () => {
  describe('-> readers', () => {
    describe('.isKeyword()', () => {});
    describe('.isDigit()', () => {});
    describe('.isIDStart()', () => {});
    describe('.isID()', () => {});
    describe('.isOpChar()', () => {});
    describe('.isPunc()', () => {});
    describe('.isWhitespace()', () => {});
  });
});

const sandbox = sinon.sandbox.create();

describe('Parser', () => {
  afterEach(() => {
    sandbox.restore();
  });

  describe('.parse()', () => {
    it('calls .makeTopLevel and returns the AST', () => {
      const expectedAST = {
        type: 'prog',
        prog: []
      };
      const makeTopLevel = sandbox.stub().returns([]);
      const input = sandbox.spy();

      const ast = parse(input, makeTopLevel);

      chai.expect(makeTopLevel.calledWith(input, [])).to.be.true;
      chai.expect(ast).to.deep.equal(expectedAST);
    });
  });
});

describe('streamer', () => {
  describe('.peek()', () => {
    it('finds the character at the current index', () => {
      const source = 'sum = fn(x, y) x + y;';
      const stream = streamer(source);

      chai.expect(stream.peek()).to.equal('s');
    });
  });

  describe('.next()', () => {
    it('moves the current index along 1 space', () => {
      const source = 'sum = fn(x, y) x + y;';
      const stream = streamer(source);

      stream.next();
      chai.expect(stream.peek()).to.equal('u');

      stream.next();
      chai.expect(stream.peek()).to.equal('m');
    });
  });

  describe('.eof()', () => {
    it('returns false if not at the end of the line', () => {
      const source = 's';
      const stream = streamer(source);

      chai.expect(stream.eof()).to.be.false;
    });

    it('returns true if not at the end of the line', () => {
      const source = 's';
      const stream = streamer(source);
      stream.next();

      chai.expect(stream.eof()).to.be.true;
    });
  });
});

describe('World', () => {
  describe('setup', () => {});
  describe('.extend()', () => {});
  describe('.lookup()', () => {});
  describe('.get()', () => {});
  describe('.set()', () => {});
  describe('.def()', () => {});
});

describe('World', () => {
  describe('-> standardLib', () => {
    describe('.log()', () => {});
  });
});
